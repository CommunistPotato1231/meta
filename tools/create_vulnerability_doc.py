"""
Script to generate a markdown file containing vulnerabilities in zopen packages.
For every package release with vulnerabilities, the file includes a dropdown menu of
all known vulnerabilities in that release, including CVE IDs and descriptions.
"""

from collections import defaultdict
import requests
import argparse

def format_quantities(cves):
    total = len(cves)
    critical = sum(1 for cve in cves if cve['severity'] == "CRITICAL")
    high = sum(1 for cve in cves if cve['severity'] == "HIGH")
    medium = sum(1 for cve in cves if cve['severity'] == "MEDIUM")
    low = sum(1 for cve in cves if cve['severity'] == "LOW")

    # Handle when all vulnerabilities have the same severity
    if total == 1:
        if critical == 1:
            return "1 critical vulnerability"
        elif high == 1:
            return "1 high vulnerability"
        elif medium == 1:
            return "1 medium vulnerability"
        elif low == 1:
            return "1 low vulnerability"
    elif critical == total:
        return f"{total} critical vulnerabilities"
    elif high == total:
        return f"{total} high vulnerabilities"
    elif medium == total:
        return f"{total} medium vulnerabilities"
    elif low == total:
        return f"{total} low vulnerabilities"

    # Handle when there are mutliple severities
    s = "1 vulnerability (" if total == 1 else f"{total} vulnerabilities ("
    first = True
    if critical > 0:
        s += f"{critical} critical"
        first = False
    if high > 0:
        if not first:
            s += ", "
        s += f"{high} high"
        first = False
    if medium > 0:
        if not first:
            s += ", "
        s += f"{medium} medium"
        first = False
    if low > 0:
        if not first:
            s += ", "
        s += f"{low} low"
        first = False
    s += ")"
    return s

def parse_release_url(url):
    release = url.split('/')[-2]
    prefix = url.split('/download/')[0]
    return f"{prefix}/tag/{release}"

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Generate markdown file for vulnerabilities in zopen packages')
    parser.add_argument('--output-file', '-o', dest='output_file', required=True, help='Output markdown file path')
    args = parser.parse_args()

    vulns_url = 'https://raw.githubusercontent.com/ZOSOpenTools/meta/main/docs/api/zopen_vulnerability.json'
    vulns_res = requests.get(vulns_url)
    vulns_json = vulns_res.json()
    releases_url = 'https://raw.githubusercontent.com/ZOSOpenTools/meta/main/docs/api/zopen_releases.json'
    releases_res = requests.get(releases_url)
    releases_json = releases_res.json()
    latest_releases_url = 'https://raw.githubusercontent.com/ZOSOpenTools/meta/main/docs/api/zopen_releases_latest.json'
    latest_releases_res = requests.get(latest_releases_url)
    latest_releases_json = latest_releases_res.json()

    package_vulns = {}
    for pkg, cves in vulns_json.items():
        # TODO: Remove this check once gitdummy is removed from zopen_vulnerability.json
        if pkg == 'gitdummy':
            continue
        if len(cves) == 0:
            continue

        package_vulns[pkg] = defaultdict(list)
        for cve in cves:
            name = cve['name']
            package_vulns[pkg][name].append(cve['CVEs'])

    release_urls = {}
    latest_release_info = {}
    for vuln_pkg, vuln_releases in package_vulns.items():
        # Get release urls for all of the releases with vulnerabilities for this package
        for release in releases_json['release_data'].get(vuln_pkg, []):
            if release['name'] in vuln_releases:
                release_urls[release['name']] = parse_release_url(release['assets'][0]['url'])
        # Get information about latest release (name, url, CVE ids)
        latest_release = latest_releases_json['release_data'].get(vuln_pkg)[0]
        info = {
            "name": latest_release['name'],
            "url": parse_release_url(latest_release['assets'][0]['url']),
            "cve_ids": set(cve['id'] for cve in vuln_releases.get(latest_release['name'], [])),
        }
        latest_release_info[vuln_pkg] = info

    with open(args.output_file, 'w') as file:
        file.write("# Package Vulnerabilities\n\n")
        for pkg, releases in package_vulns.items():
            file.write(f"## {pkg}\n\n")
            # List of releases for this package
            for release, cves in releases.items():
                # Dropdown for each release -- expand to show vulnerabilities
                file.write(f"<details>\n<summary>{release} -- {format_quantities(cves)}</summary>\n\n")

                # Url of release page and url of latest release (if this is not the latest release)
                file.write(f"- Release URL: [{release}]({release_urls[release]})\n\n")
                latest_release = latest_release_info[pkg]
                if release == latest_release['name']:
                    file.write("- This is the latest release.\n\n")
                else:
                    file.write(f"- Latest release: [{latest_release['name']}]({latest_release['url']})\n\n")

                for cve in cves:
                    # Bullet point for each vulnerability in this release
                    file.write(f"- **({cve['severity']} severity) {cve['id']}**: {cve['details']}\n")
                    # Show if this vulnerability is resolved in the latest release
                    if (release != latest_release_info[pkg]['name'] and
                            cve['id'] not in latest_release_info[pkg]['cve_ids']):
                        file.write("  - **This vulnerability is resolved in the latest release.**\n")
                file.write("\n</details>\n\n")

        if len(package_vulns) == 0:
            file.write("There are currently no known vulnerabilities in any packages.")

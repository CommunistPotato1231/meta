#!/bin/sh
# Cleanup utility for z/OS Open Tools - https://github.com/ZOSOpenTools

#
# All zopen-* scripts MUST start with this code to maintain consistency
#
setupMyself()
{
  ME=$(basename $0)
  MYDIR="$(cd "$(dirname "$0")" > /dev/null 2>&1 && pwd -P)"
  INCDIR="${MYDIR}/../include"
  if ! [ -d "${INCDIR}" ] && ! [ -f "${INCDIR}/common.sh" ]; then
    echo "Internal Error. Unable to find common.sh file to source" >&2
    exit 8
  fi
  . "${INCDIR}/common.sh"
}
setupMyself
checkWritable

printHelp()
{
  cat << HELPDOC
zopen clean is a utility for z/OS Open Tools to clean uneeded resources
from the system to save space and prevent clutter

Usage: zopen clean [OPTION] [PACKAGE]

Options:
  -c, --cache       cleans the downloaded package cache; packages will be re-downloaded if needed
  -d, --dangling    removes dangling symlinks from the zopen file system in case of issues during
                    package maintenance
  -u, --unused [PACKAGE]     
                    remove versions of PACKAGE that are available as alternatives, leaving only the 
                    currently active version
  -v, --verbose     run in verbose mode
  -h,-?, --help     display this help and exit
  --version         print version

Examples:
  zopen clean -c    clear the package download cache
  zopen clean -d    analyse the zopen file system and remove any dangling symlinks
  zopen clean -u [PACKAGE]
                    remove unused versions for PACKAGE

Report bugs at https://github.com/ZOSOpenTools/meta/issues .

HELPDOC
}

cleanUnused()
{
  needle=$1
  [ -z "${needle}" ] && return 
  current=$(getCurrentVersionDir "${needle}")

  if [ -n "${current}" ]; then
    current=$(basename "${current}")
  else
    printInfo "No currently active version of '${needle}'; removing all versions"
  fi
  cd "${ZOPEN_PKGINSTALL}/${needle}" && zosfind . -name "./*" -prune -type d |
  while read repo; do
    printVerbose "Parsing repo: '${repo}' as '${repo#./}'"
    repo="${repo#./}"
    if [ "${current}" = "${repo}" ]; then
      printInfo "${NC}${GREEN}-> ${repo}  <- Current version${NC}"
    else
      echo rm -rf "${ZOPEN_PKGINSTALL}/${needle}/${repo}" #> /dev/null 2>&1
      printInfo "-- ${repo} <- Removed"
      syslog "${ZOPEN_LOG_PATH}/audit.log" "${LOG_A}" "${CAT_FILE},${CAT_PACKAGE},${CAT_REMOVE}" "CLEAN" "cleanUnused" "Removed unused package at ${repo#"${ZOPEN_PKGINSTALL}"/} "
    fi
  done  
}

cleanDangling()
{
  printVerbose "Removing dangling symlinks from the file structure"
  # As packages can install to any subfolder of the zopen filesystem, need to traverse
  # along every path under that filesystem
  deref=$(cd "${ZOPEN_ROOTFS}" && pwd -P)
  if [ "${deref}" = "/" ]; then
    printWarning "With zopen's root configured as '/', traversal to find dangling symlinks"
    printWarning "will occur on ALL mounted file systems, ALL sub-directories and will"
    printWarning "attempt to remove any dangling symlinks it finds, regardless of how they"
    printWarning "were created or which package/product/install mechanism was used and if "
    printWarning "the user has permission to do so (errors will be reported if not)."
    printWarning "This is due to individual packages potentially installing to any location"
    printWarning "within the zopen file structure so all locations need to be considered"
    printWarning "and analysed."
    printWarning "Are you absolutely sure you want to run this option (y/N)?"
    read absolutely < /dev/tty
    if [ -n "${absolutely}" ] && [ "y" = "${absolutely}" ]; then
      printInfo "- Checking for any dangling symlinks across system"
    else
      exit 4
    fi
  fi
  progressHandler "spinner" "- Dangling link removal complete" &
  ph=$!
  killph="kill -HUP ${ph}"
  addCleanupTrapCmd "${killph}"
  zosfind "${ZOPEN_ROOTFS}" -type l -exec test ! -e {} \; -print | while read sl; do
    printVerbose "Removing symlink '${sl}'"
    rm -f "${sl}"
  done
  ${killph} 2> /dev/null # if the timer is not running, the kill will fail
  syslog "${ZOPEN_LOG_PATH}/audit.log" "${LOG_A}" "${CAT_FILE}" "CLEAN" "cleanDangling" "zopen system at '${ZOPEN_ROOTFS}' scanned for dangling symlinks"
}

cleanCache()
{
  printVerbose "Cleaning ${ZOPEN_ROOTFS}/var/cache/zopen"
  rm -rf "${ZOPEN_ROOTFS}/var/cache/zopen/"*
  syslog "${ZOPEN_LOG_PATH}/audit.log" "${LOG_A}" "${CAT_FILE}" "CLEAN" "cleanCache" "Main cache in ${ZOPEN_ROOTFS}/var/cache/zopen cleaned"
  printInfo "- Cache at '${ZOPEN_ROOTFS}/var/cache/zopen' cleaned"
}

# Main code start here
args=$*
verbose=false
debug=false
unused=false
dangling=false
cache=false
package=""

if [ $# -eq 0 ]; then
  printError "No option provided for cleaning"
fi
while [ $# -gt 0 ]; do
  printVerbose "Parsing option: $1"
  case "$1" in
  "-u" | "--unused")
    shift
    [ $# -lt 1 ] && printError "Missing parameter for 'clean unused' option"
    unused=true
    dangling=false
    cache=false
    package="$1"
    ;;
  "-d" | "--dangling")
    unused=false
    dangling=true
    cache=false
    ;;
  "-c" | "--cache")
    unused=false
    dangling=false
    cache=true
    ;;
  "-h" | "--help" | "-?")
    printHelp "${args}"
    exit 0
    ;;
  "--version")
    zopen-version ${ME}
    exit 0
    ;;
  "-v" | "--verbose")
    verbose=true
    ;;
  "--debug")
    verbose=true
    debug=true
    ;;
  *)
    package="$1" # Use the last unrecognised parameter as the package
    ;;
  esac
  shift
done

if ${unused}; then
  cleanUnused "${package}"
fi
if ${dangling}; then
  cleanDangling
fi
if ${cache}; then
  cleanCache
fi

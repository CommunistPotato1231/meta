#!/bin/sh
#
# Install utility for zopen community - https://github.com/zopencommunity
#

#
# All zopen-* scripts MUST start with this code to maintain consistency.
#
setupMyself()
{
  ME=$(basename "$0")
  MYDIR="$(cd "$(dirname "$0")" > /dev/null 2>&1 && pwd -P)"
  INCDIR="${MYDIR}/../include"
  if ! [ -d "${INCDIR}" ] && ! [ -f "${INCDIR}/common.sh" ]; then
    echo "Internal Error. Unable to find common.sh file to source." >&2
    exit 8
  fi
  # shellcheck source=/dev/null
  . "${INCDIR}/common.sh"
}
setupMyself
checkWritable

verifySignatureOfPax()
{
  # Extracting values and checking for errors
  if ! FILE_TO_VERIFY=$(jq -e -r '.product.pax' "${metadataFile}"); then
     printError "Failed to extract 'pax' from ${metadataFile}" >&2
  fi

  if ! SIGNATURE=$(jq -e -r '.product.signature' "${metadataFile}"); then 
    printVerbose "Failed to extract 'signature' from ${metadataFile}" >&2
    return
  fi

  if ! PUBLIC_KEY=$(jq -e -r '.product.public_key' "${metadataFile}"); then 
     printError "Failed to extract 'public_key' from ${metadataFile}" >&2
  fi


  # Create a temporary directory for GPG keyring
  TMP_GPG_DIR="$zopen_tmp_dir/tmp_gpg_verify"
  mkdir -p "$TMP_GPG_DIR"

  SIGNATURE_FILE="$zopen_tmp_dir/signedfile.asc"
  PUBLIC_KEY_FILE="$zopen_tmp_dir/scriptpubkey.asc"
  printf "%b" "$SIGNATURE" | tr -d '"'  > "$SIGNATURE_FILE"
  printf "%b" "$PUBLIC_KEY" | tr -d '"'  > "$PUBLIC_KEY_FILE"

  printVerbose "Importing public key..."
  [ -f "$PUBLIC_KEY_FILE" ] && gpg --no-default-keyring --keyring "$TMP_GPG_DIR/pubring.kbx" --batch --yes --import "$PUBLIC_KEY_FILE" > /dev/null 2>&1
  if [ $? -ne 0 ]; then
      [ -e "${TMP_GPG_DIR}" ] && rm -rf "$TMP_GPG_DIR"
      printError "Importing public key failed. Verification aborted."
  fi

  # Verify that the key was imported successfully
  printVerbose "Checking if public key is imported..."
  gpg --no-default-keyring --keyring "$TMP_GPG_DIR/pubring.kbx" --list-keys > /dev/null 2>&1
  if [ $? -ne 0 ]; then
      [ -e "${TMP_GPG_DIR}" ] && rm -rf "$TMP_GPG_DIR"
      printError "No public key found. Verification aborted."
  fi

  # Verify the signature
  printInfo "Verifying the gpg signature..."
  if [ -f "$SIGNATURE_FILE" ]; then
        if gpg --no-default-keyring --keyring "$TMP_GPG_DIR/pubring.kbx" --verify "$SIGNATURE_FILE" "$FILE_TO_VERIFY" 2>&1 | grep -q "Good signature from"; then
           printInfo "${NC}${GREEN}Signature verified successfully: ${name}${NC}"
           return 0
        else
           [ -e "${TMP_GPG_DIR}" ] && rm -rf "$TMP_GPG_DIR"
           printError "Verification failed."
        fi
   else
        printError "Signature file does not exist."
  fi
  
  # Clean up the temporary directory/files
  [ -e "${SIGNATURE_FILE}" ] && rm -rf "${SIGNATURE_FILE}"
  [ -e "${PUBLIC_KEY_FILE}" ] && rm -rf "${PUBLIC_KEY_FILE}"
  [ -e "${TMP_GPG_DIR}" ] && rm -rf "${TMP_GPG_DIR}"
}

printSyntax()
{
cat << HELPDOC
${ME} is a utility to download/install a zopen community package.

Usage: zopen install [OPTION] [PARAMETERS] [PACKAGES]

Options:
  --all                    download/install all zopen community packages.
  --bypass-prereq-checks   Ignores pre-req checks
  --download-only          download package to current directory.
  --force                  force install, bypassing locks.
  --help                   print this help.
  --install-or-upgrade     installs the package if not installed,
                           or upgrades the package if installed.
  --no-deps                do not install dependencies.
  --no-set-active          do not change the pinned version.
  --nosymlink              do not integrate into filesystem through
                           symlink redirection.
  --reinstall              reinstall already installed zopen community packages.
  --release-line [stable, dev] the release line to build off of.
  --select                 select a version to install.
  -u, --upgrade     check for package updates and apply
  -v, --verbose            print verbose messages.
  --version                print version.
  -y, --yes                automatically answer yes to prompts.

HELPDOC
}

# Main code start here
# Need to set a number of variables for use in the install function
# which is common between install & upgrade
args=$*
verbose=false
debug=false
xdebug=false
quiet=false
selectVersion=false
# shellcheck disable=SC2034
setActive=true
downloadOnly=false
reinstall=false
installOrUpgrade=false
nosymlink=false
skipupgrade=false
skipverify=false
doNotInstallDeps=false
all=false
yesToPrompts=falseskipupgrade
bypassPrereqs=false
force=false
chosenRepos=""
fileinstall=false

while [ $# -gt 0 ]; do
  case "$1" in
    "-r" | "-reinstall" | "--reinstall")
      # shellcheck disable=SC2034
      reinstall=true  # If package already installed, reinstall
      ;;
    "--install-or-upgrade")
      # shellcheck disable=SC2034
      installOrUpgrade=true  # Upgrade package or install if not present
      ;;
    "--bypass-prereq-checks")
      bypassPrereqs=true 
      ;;
    "--no-symlink")
      # shellcheck disable=SC2034
      nosymlink=true  # Do not mesh the package into the file system; leave as stand-alone
      ;;
    "--no-deps")
      doNotInstallDeps=true
      ;;
    "--release-line")
      shift
      # shellcheck disable=SC2034
      releaseLine=$(echo "$1" | awk '{print toupper($0)}')
      ;;
    "--yes" | "-y")
      # shellcheck disable=SC2034
      yesToPrompts=true  # Automatically answer 'yes' to any questions
      ;;
    "--download-only")
      downloadOnly=true  # Download remote package files to current directory only
      ;;
    "--no-set-active")
      # shellcheck disable=SC2034
      setactive=false  # Install package as normal but keep existing installation as active
      ;;
    "--skip-verify" | "-sv")
      # shellcheck disable=SC2034
      skipverify=true # Verify signature of packages
      ;;
    "--force")
      # shellcheck disable=SC2034
      force=true # Bypasses locks
      ;;
    "--all")
      all=true  # Install all packages
      ;;
    "--select")
      # shellcheck disable=SC2034
      selectVersion=true  # Display a selction table to allow version picking
      ;;
    "-h" | "--help" | "-?")
      printHelp "${args}"
      exit 0
      ;;
    "--debug")
      verbose=true
      # shellcheck disable=SC2034
      debug=true
      ;;
    "-v" | "--verbose")
      # shellcheck disable=SC2034
      verbose=true
      ;;
    "--xdebug")
      xdebug=true
    ;;
    "--quiet")
      # shellcheck disable=SC2034
      quiet=true
    ;;
  "--version")
    zopen-version "${ME}"
    exit 0
    ;;

  -*) printError "Unsupported parameter '$1'";;
  *)
    # Generate a long @@ separated string to allow for embedded
    # spaces in hardcoded pax filenames
    chosenRepos="${chosenRepos}@@$1"
    ;;
  esac
  shift
done

${xdebug} && set -x && printVerbose "Enabled command execution trace" 

if ! ${all} && [ -z "${chosenRepos}" ]; then
  printInfo "No packages selected for installation."
  exit 4
fi

# If any of the parameters passed in point to an existing file, then
# the user is attempting to install a port directly from the file system
# rather than a repo
printDebug "Checking input parameters for actual files"
potentials=$(echo "${chosenRepos}" | sed 's/@@/ /g')
for installRepo in ${potentials}; do
  [ -f "${installRepo}" ] && fileinstall=true && break
done

if [ ! ${fileinstall} ]; then 
  printVerbose "Using potentially remote files; ensuring configured for remte access"
  checkIfConfigLoaded
fi

mutexReq "zopen" "zopen"
if ${downloadOnly}; then
  downloadDir="${PWD}"
  printDebug "Downloading pax to current directory '${downloadDir}'"
else
  printDebug "Installing to zopen file system: ${ZOPEN_ROOTFS}"
  if [ -z "${ZOPEN_ROOTFS}" ]; then
    printError "Unable to locate zopen file system, \${ZOPEN_ROOTFS} is undefined. Re-source zopen-config and retry command."
  fi
  downloadDir="${ZOPEN_ROOTFS}/var/cache/zopen"
fi

if [ ! -d "${downloadDir}" ]; then
  if ! mkdir -p "${downloadDir}"; then
    printError "Could not create download directory: ${downloadDir}. Check permissions and retry command."
  fi
fi

printDebug "Checking if installing from pax files: ${fileinstall}"
if ! ${fileinstall}; then
  printVerbose "Querying metadata for latest package information"
  getRepos
  grfgRc=$?
  [ 0 -ne ${grfgRc} ] && exit ${grfgRc};
fi

if ${fileinstall}; then
  printDebug "Installing from files as listed in arguments: '${chosenRepos}'"
  # generate the install list JSON from the @@-delimited inputs
  installList=$(echo "${chosenRepos}" \
    | jq --raw-input --arg d "$(pwd -P)" \
    'def make_object($url): {asset:{url: ( "file://" + $d + "/" + $url  )}}; . | split("@@") | map(select(.!="")|make_object(.)) | {"installqueue" :.} ')
else
  if ${all}; then
    # shellcheck disable=SC2034
    doNotInstallDeps=true
    installList=$(jq --raw-output '.release_data| keys[]' "${JSON_CACHE}") 
    installListCount=$(jq --raw-output '.release_data| keys | length' "${JSON_CACHE}") 
    printInfo "- Installing all currently-uninstalled packages"
    printInfo "- Checking installation status for '${installListCount}' packages"
  else
    installList=$(echo "$chosenRepos" | sed "s/@@/ /g")
    validateInstallList "${installList}"
  fi
  printInfo "- Generating install graph"
  progressHandler "spinner" "- Generated install graph" &
  gigph=$!
  killph="kill -HUP ${gigph}"
  addCleanupTrapCmd "${killph}"
  generateInstallGraph "${installList}"
  ${killph} 2>/dev/null # if the timer is not running, the kill will fail
  waitforpid ${gigph}  # Make sure it's finished writing to screen
fi

if [ 0 -eq "$(echo "${installList}" | jq --raw-output '.installqueue| length')" ]; then
  printInfo "- No packages for install"
else
  if ${verbose}; then 
    printInfo " - The following package(s) will be installed:"
    echo "${installList}" | jq --raw-output '.installqueue | sort| .[] | .portname '
  fi
  processRepoInstallFile

fi
mutexFree "zopen"
exit
